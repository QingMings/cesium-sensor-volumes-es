(function(e,C){typeof exports=="object"&&typeof module<"u"?module.exports=C(require("cesium")):typeof define=="function"&&define.amd?define(["cesium"],C):(e=typeof globalThis<"u"?globalThis:e||self,e.CesiumSensorVolumes=C(e.Cesium))})(this,function(e){"use strict";const C=function(t){this._minimumClockAngle=void 0,this._minimumClockAngleSubscription=void 0,this._maximumClockAngle=void 0,this._maximumClockAngleSubscription=void 0,this._innerHalfAngle=void 0,this._innerHalfAngleSubscription=void 0,this._outerHalfAngle=void 0,this._outerHalfAngleSubscription=void 0,this._lateralSurfaceMaterial=void 0,this._lateralSurfaceMaterialSubscription=void 0,this._intersectionColor=void 0,this._intersectionColorSubscription=void 0,this._intersectionWidth=void 0,this._intersectionWidthSubscription=void 0,this._showIntersection=void 0,this._showIntersectionSubscription=void 0,this._radius=void 0,this._radiusSubscription=void 0,this._show=void 0,this._showSubscription=void 0,this._definitionChanged=new e.Event,this.merge(e.defaultValue(t,e.defaultValue.EMPTY_OBJECT))};Object.defineProperties(C.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},minimumClockAngle:e.createPropertyDescriptor("minimumClockAngle"),maximumClockAngle:e.createPropertyDescriptor("maximumClockAngle"),innerHalfAngle:e.createPropertyDescriptor("innerHalfAngle"),outerHalfAngle:e.createPropertyDescriptor("outerHalfAngle"),lateralSurfaceMaterial:e.createMaterialPropertyDescriptor("lateralSurfaceMaterial"),intersectionColor:e.createPropertyDescriptor("intersectionColor"),intersectionWidth:e.createPropertyDescriptor("intersectionWidth"),showIntersection:e.createPropertyDescriptor("showIntersection"),radius:e.createPropertyDescriptor("radius"),show:e.createPropertyDescriptor("show")}),C.prototype.clone=function(t){return e.defined(t)||(t=new C),t.show=this.show,t.innerHalfAngle=this.innerHalfAngle,t.outerHalfAngle=this.outerHalfAngle,t.minimumClockAngle=this.minimumClockAngle,t.maximumClockAngle=this.maximumClockAngle,t.radius=this.radius,t.showIntersection=this.showIntersection,t.intersectionColor=this.intersectionColor,t.intersectionWidth=this.intersectionWidth,t.lateralSurfaceMaterial=this.lateralSurfaceMaterial,t},C.prototype.merge=function(t){if(!e.defined(t))throw new e.DeveloperError("source is required.");this.show=e.defaultValue(this.show,t.show),this.innerHalfAngle=e.defaultValue(this.innerHalfAngle,t.innerHalfAngle),this.outerHalfAngle=e.defaultValue(this.outerHalfAngle,t.outerHalfAngle),this.minimumClockAngle=e.defaultValue(this.minimumClockAngle,t.minimumClockAngle),this.maximumClockAngle=e.defaultValue(this.maximumClockAngle,t.maximumClockAngle),this.radius=e.defaultValue(this.radius,t.radius),this.showIntersection=e.defaultValue(this.showIntersection,t.showIntersection),this.intersectionColor=e.defaultValue(this.intersectionColor,t.intersectionColor),this.intersectionWidth=e.defaultValue(this.intersectionWidth,t.intersectionWidth),this.lateralSurfaceMaterial=e.defaultValue(this.lateralSurfaceMaterial,t.lateralSurfaceMaterial)};const H=`#version 300 es

uniform vec4 u_intersectionColor;
uniform float u_intersectionWidth;

bool inSensorShadow(vec3 coneVertexWC, vec3 pointWC)
{
    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.
    vec3 D = czm_ellipsoidInverseRadii;

    // Sensor vertex in the scaled ellipsoid space
    vec3 q = D * coneVertexWC;
    float qMagnitudeSquared = dot(q, q);
    float test = qMagnitudeSquared - 1.0;

    // Sensor vertex to fragment vector in the ellipsoid's scaled space
    vec3 temp = D * pointWC - q;
    float d = dot(temp, q);

    // Behind silhouette plane and inside silhouette cone
    return (d < -test) && (d / length(temp) < -sqrt(test));
}

vec4 getIntersectionColor()
{
    return u_intersectionColor;
}

float getIntersectionWidth()
{
    return u_intersectionWidth;
}

vec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)
{
    // (s, t) both in the range [0, 1]
    float t = pointMC.z / sensorRadius;
    float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);
    s = s - floor(s);

    return vec2(s, t);
}
`,k=`#version 300 es

uniform bool u_showIntersection;
uniform bool u_showThroughEllipsoid;

uniform float u_sensorRadius;
uniform float u_normalDirection;

in vec3 v_positionWC;
in vec3 v_positionEC;
in vec3 v_normalEC;

vec4 getColor(float sensorRadius, vec3 pointEC)
{
    czm_materialInput materialInput;

    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;
    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);
    materialInput.str = pointMC / sensorRadius;

    vec3 positionToEyeEC = -v_positionEC;
    materialInput.positionToEyeEC = positionToEyeEC;

    vec3 normalEC = normalize(v_normalEC);
    materialInput.normalEC = u_normalDirection * normalEC;

    czm_material material = czm_getMaterial(materialInput);
    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);
}

bool isOnBoundary(float value, float epsilon)
{
    float width = getIntersectionWidth();
    float tolerance = width * epsilon;

    float delta = max(abs(dFdx(value)), abs(dFdy(value)));
    float pixels = width * delta;
    float temp = abs(value);
    // There are a couple things going on here.
    // First we test the value at the current fragment to see if it is within the tolerance.
    // We also want to check if the value of an adjacent pixel is within the tolerance,
    // but we don't want to admit points that are obviously not on the surface.
    // For example, if we are looking for "value" to be close to 0, but value is 1 and the adjacent value is 2,
    // then the delta would be 1 and "temp - delta" would be "1 - 1" which is zero even though neither of
    // the points is close to zero.
    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);
}

vec4 shade(bool isOnBoundary)
{
    if (u_showIntersection && isOnBoundary)
    {
        return getIntersectionColor();
    }
    return getColor(u_sensorRadius, v_positionEC);
}

float ellipsoidSurfaceFunction(vec3 point)
{
    vec3 scaled = czm_ellipsoidInverseRadii * point;
    return dot(scaled, scaled) - 1.0;
}

void main()
{
    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates
    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates

    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);

    // Occluded by the ellipsoid?
    if (!u_showThroughEllipsoid)
    {
        // Discard if in the ellipsoid
        // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.
        if (ellipsoidValue < 0.0)
        {
            discard;
        }

        // Discard if in the sensor's shadow
        if (inSensorShadow(sensorVertexWC, v_positionWC))
        {
            discard;
        }
    }

    // Discard if not in the sensor's sphere
    // PERFORMANCE_IDEA: We can omit this check if the radius is Number.POSITIVE_INFINITY.
    if (distance(v_positionEC, sensorVertexEC) > u_sensorRadius)
    {
        discard;
    }

    // Notes: Each surface functions should have an associated tolerance based on the floating point error.
    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);
    out_FragColor = shade(isOnEllipsoid);
}
`,m=`#version 300 es

in vec4 position;
in vec3 normal;

out vec3 v_positionWC;
out vec3 v_positionEC;
out vec3 v_normalEC;

void main()
{
    gl_Position = czm_modelViewProjection * position;
    v_positionWC = (czm_model * position).xyz;
    v_positionEC = (czm_modelView * position).xyz;
    v_normalEC = czm_normal * normal;
}
`,D={position:0,normal:1},F=5906376272e3,S=function(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT),this._pickId=void 0,this._pickPrimitive=e.defaultValue(t._pickPrimitive,this),this._frontFaceColorCommand=new e.DrawCommand,this._backFaceColorCommand=new e.DrawCommand,this._pickCommand=new e.DrawCommand,this._boundingSphere=new e.BoundingSphere,this._boundingSphereWC=new e.BoundingSphere,this._frontFaceColorCommand.primitiveType=e.PrimitiveType.TRIANGLES,this._frontFaceColorCommand.boundingVolume=this._boundingSphereWC,this._frontFaceColorCommand.owner=this,this._backFaceColorCommand.primitiveType=this._frontFaceColorCommand.primitiveType,this._backFaceColorCommand.boundingVolume=this._frontFaceColorCommand.boundingVolume,this._backFaceColorCommand.owner=this,this._pickCommand.primitiveType=this._frontFaceColorCommand.primitiveType,this._pickCommand.boundingVolume=this._frontFaceColorCommand.boundingVolume,this._pickCommand.owner=this,this.show=e.defaultValue(t.show,!0),this.showIntersection=e.defaultValue(t.showIntersection,!0),this.showThroughEllipsoid=e.defaultValue(t.showThroughEllipsoid,!1),this._showThroughEllipsoid=this.showThroughEllipsoid,this.modelMatrix=e.Matrix4.clone(e.defaultValue(t.modelMatrix,e.Matrix4.IDENTITY)),this._modelMatrix=new e.Matrix4,this.radius=e.defaultValue(t.radius,Number.POSITIVE_INFINITY),this._directions=void 0,this._directionsDirty=!1,this.directions=e.defined(t.directions)?t.directions:[],this.lateralSurfaceMaterial=e.defined(t.lateralSurfaceMaterial)?t.lateralSurfaceMaterial:e.Material.fromType(e.Material.ColorType),this._lateralSurfaceMaterial=void 0,this._translucent=void 0,this.intersectionColor=e.Color.clone(e.defaultValue(t.intersectionColor,e.Color.WHITE)),this.intersectionWidth=e.defaultValue(t.intersectionWidth,5),this.id=t.id,this._id=void 0;var i=this;this._uniforms={u_showThroughEllipsoid:function(){return i.showThroughEllipsoid},u_showIntersection:function(){return i.showIntersection},u_sensorRadius:function(){return isFinite(i.radius)?i.radius:F},u_intersectionColor:function(){return i.intersectionColor},u_intersectionWidth:function(){return i.intersectionWidth},u_normalDirection:function(){return 1}},this._mode=e.SceneMode.SCENE3D};Object.defineProperties(S.prototype,{directions:{get:function(){return this._directions},set:function(t){this._directions=t,this._directionsDirty=!0}}});const B=new e.Cartesian3,q=new e.Cartesian3,L=new e.Cartesian3;function Q(t){for(var i=t._directions,l=i.length,s=new Float32Array(3*l),n=isFinite(t.radius)?t.radius:F,r=[e.Cartesian3.ZERO],a=l-2,o=l-1,h=0;h<l;a=o++,o=h++){var u=e.Cartesian3.fromSpherical(i[a],B),d=e.Cartesian3.fromSpherical(i[o],q),c=e.Cartesian3.fromSpherical(i[h],L),f=Math.max(e.Cartesian3.angleBetween(u,d),e.Cartesian3.angleBetween(d,c)),_=n/Math.cos(f*.5),g=e.Cartesian3.multiplyByScalar(d,_,new e.Cartesian3);s[o*3]=g.x,s[o*3+1]=g.y,s[o*3+2]=g.z,r.push(g)}return e.BoundingSphere.fromPoints(r,t._boundingSphere),s}const z=new e.Cartesian3;function Y(t,i){for(var l=Q(t),s=t._directions.length,n=new Float32Array(2*3*3*s),r=0,a=s-1,o=0;o<s;a=o++){var h=new e.Cartesian3(l[a*3],l[a*3+1],l[a*3+2]),u=new e.Cartesian3(l[o*3],l[o*3+1],l[o*3+2]),d=e.Cartesian3.normalize(e.Cartesian3.cross(u,h,z),z);n[r++]=0,n[r++]=0,n[r++]=0,n[r++]=d.x,n[r++]=d.y,n[r++]=d.z,n[r++]=u.x,n[r++]=u.y,n[r++]=u.z,n[r++]=d.x,n[r++]=d.y,n[r++]=d.z,n[r++]=h.x,n[r++]=h.y,n[r++]=h.z,n[r++]=d.x,n[r++]=d.y,n[r++]=d.z}var c=e.Buffer.createVertexBuffer({context:i,typedArray:new Float32Array(n),usage:e.BufferUsage.STATIC_DRAW}),f=2*3*Float32Array.BYTES_PER_ELEMENT,_=[{index:D.position,vertexBuffer:c,componentsPerAttribute:3,componentDatatype:e.ComponentDatatype.FLOAT,offsetInBytes:0,strideInBytes:f},{index:D.normal,vertexBuffer:c,componentsPerAttribute:3,componentDatatype:e.ComponentDatatype.FLOAT,offsetInBytes:3*Float32Array.BYTES_PER_ELEMENT,strideInBytes:f}];return new e.VertexArray({context:i,attributes:_})}S.prototype.update=function(t){if(this._mode=t.mode,!(!this.show||this._mode!==e.SceneMode.SCENE3D)){var i=t.context,l=t.commandList;if(this.radius<0)throw new e.DeveloperError("this.radius must be greater than or equal to zero.");if(!e.defined(this.lateralSurfaceMaterial))throw new e.DeveloperError("this.lateralSurfaceMaterial must be defined.");var s=this.lateralSurfaceMaterial.isTranslucent();if(this._showThroughEllipsoid!==this.showThroughEllipsoid||!e.defined(this._frontFaceColorCommand.renderState)||this._translucent!==s){this._showThroughEllipsoid=this.showThroughEllipsoid,this._translucent=s;var n;s?(n=e.RenderState.fromCache({depthTest:{enabled:!this.showThroughEllipsoid},depthMask:!1,blending:e.BlendingState.ALPHA_BLEND,cull:{enabled:!0,face:e.CullFace.BACK}}),this._frontFaceColorCommand.renderState=n,this._frontFaceColorCommand.pass=e.Pass.TRANSLUCENT,n=e.RenderState.fromCache({depthTest:{enabled:!this.showThroughEllipsoid},depthMask:!1,blending:e.BlendingState.ALPHA_BLEND,cull:{enabled:!0,face:e.CullFace.FRONT}}),this._backFaceColorCommand.renderState=n,this._backFaceColorCommand.pass=e.Pass.TRANSLUCENT,n=e.RenderState.fromCache({depthTest:{enabled:!this.showThroughEllipsoid},depthMask:!1,blending:e.BlendingState.ALPHA_BLEND}),this._pickCommand.renderState=n):(n=e.RenderState.fromCache({depthTest:{enabled:!0},depthMask:!0}),this._frontFaceColorCommand.renderState=n,this._frontFaceColorCommand.pass=e.Pass.OPAQUE,n=e.RenderState.fromCache({depthTest:{enabled:!0},depthMask:!0}),this._pickCommand.renderState=n)}var r=this._directionsDirty;if(r){this._directionsDirty=!1,this._va=this._va&&this._va.destroy();var a=this._directions;a&&a.length>=3&&(this._frontFaceColorCommand.vertexArray=Y(this,i),this._backFaceColorCommand.vertexArray=this._frontFaceColorCommand.vertexArray,this._pickCommand.vertexArray=this._frontFaceColorCommand.vertexArray)}if(e.defined(this._frontFaceColorCommand.vertexArray)){var o=t.passes,h=!e.Matrix4.equals(this.modelMatrix,this._modelMatrix);h&&e.Matrix4.clone(this.modelMatrix,this._modelMatrix),(r||h)&&e.BoundingSphere.transform(this._boundingSphere,this.modelMatrix,this._boundingSphereWC),this._frontFaceColorCommand.modelMatrix=this.modelMatrix,this._backFaceColorCommand.modelMatrix=this._frontFaceColorCommand.modelMatrix,this._pickCommand.modelMatrix=this._frontFaceColorCommand.modelMatrix;var u=this._lateralSurfaceMaterial!==this.lateralSurfaceMaterial;if(this._lateralSurfaceMaterial=this.lateralSurfaceMaterial,this._lateralSurfaceMaterial.update(i),o.render){var d=this._frontFaceColorCommand,c=this._backFaceColorCommand;if(u||!e.defined(d.shaderProgram)){var f=new e.ShaderSource({sources:[H,this._lateralSurfaceMaterial.shaderSource,k]});d.shaderProgram=e.ShaderProgram.replaceCache({context:i,shaderProgram:d.shaderProgram,vertexShaderSource:m,fragmentShaderSource:f,attributeLocations:D}),d.uniformMap=e.combine(this._uniforms,this._lateralSurfaceMaterial._uniforms),c.shaderProgram=d.shaderProgram,c.uniformMap=e.combine(this._uniforms,this._lateralSurfaceMaterial._uniforms),c.uniformMap.u_normalDirection=function(){return-1}}s?l.push(this._backFaceColorCommand,this._frontFaceColorCommand):l.push(this._frontFaceColorCommand)}if(o.pick){var _=this._pickCommand;if((!e.defined(this._pickId)||this._id!==this.id)&&(this._id=this.id,this._pickId=this._pickId&&this._pickId.destroy(),this._pickId=i.createPickId({primitive:this._pickPrimitive,id:this.id})),u||!e.defined(_.shaderProgram)){var g=new e.ShaderSource({sources:[H,this._lateralSurfaceMaterial.shaderSource,k],pickColorQualifier:"uniform"});_.shaderProgram=e.ShaderProgram.replaceCache({context:i,shaderProgram:_.shaderProgram,vertexShaderSource:m,fragmentShaderSource:g,attributeLocations:D});var I=this,b={czm_pickColor:function(){return I._pickId.color}};_.uniformMap=e.combine(e.combine(this._uniforms,this._lateralSurfaceMaterial._uniforms),b)}_.pass=s?e.Pass.TRANSLUCENT:e.Pass.OPAQUE,l.push(_)}}}},S.prototype.isDestroyed=function(){return!1},S.prototype.destroy=function(){return this._frontFaceColorCommand.vertexArray=this._frontFaceColorCommand.vertexArray&&this._frontFaceColorCommand.vertexArray.destroy(),this._frontFaceColorCommand.shaderProgram=this._frontFaceColorCommand.shaderProgram&&this._frontFaceColorCommand.shaderProgram.destroy(),this._pickCommand.shaderProgram=this._pickCommand.shaderProgram&&this._pickCommand.shaderProgram.destroy(),this._pickId=this._pickId&&this._pickId.destroy(),e.destroyObject(this)};function v(t,i,l){var s=i[t.id];if(e.defined(s)){var n=s.primitive;l.remove(n),n.isDestroyed()||n.destroy(),delete i[t.id]}}const $=e.Color.WHITE,j=1,J=Number.POSITIVE_INFINITY,K=new e.Matrix3,U=new e.Cartesian3,X=new e.Quaternion;function P(t,i,l,s){var n=i[t];e.defined(n)||(n=new e.Spherical,i[t]=n),n.clock=l,n.cone=s,n.magnitude=1}function Z(t,i,l,s,n){var r=t.directions,a,o=0,h=e.Math.toRadians(2);if(i===0&&l===e.Math.TWO_PI)for(a=0;a<e.Math.TWO_PI;a+=h)P(o++,r,a,n);else{for(a=i;a<l;a+=h)P(o++,r,a,n);if(P(o++,r,l,n),s){for(a=l;a>i;a-=h)P(o++,r,a,s);P(o++,r,i,s)}else P(o++,r,l,0)}r.length=o,t.directions=r}const w=function(t,i){if(!e.defined(t))throw new e.DeveloperError("scene is required.");if(!e.defined(i))throw new e.DeveloperError("entityCollection is required.");i.collectionChanged.addEventListener(w.prototype._onCollectionChanged,this),this._scene=t,this._primitives=t.primitives,this._entityCollection=i,this._hash={},this._entitiesToVisualize=new e.AssociativeArray,this._onCollectionChanged(i,i.values,[],[])};w.prototype.update=function(t){if(!e.defined(t))throw new e.DeveloperError("time is required.");for(var i=this._entitiesToVisualize.values,l=this._hash,s=this._primitives,n=0,r=i.length;n<r;n++){var a=i[n],o=a._conicSensor,h,u,d=l[a.id],c=a.isShowing&&a.isAvailable(t)&&e.Property.getValueOrDefault(o._show,t,!0);if(c&&(h=e.Property.getValueOrUndefined(a._position,t,U),u=e.Property.getValueOrUndefined(a._orientation,t,X),c=e.defined(h)&&e.defined(u)),!c){e.defined(d)&&(d.primitive.show=!1);continue}var f=e.defined(d)?d.primitive:void 0;e.defined(f)||(f=new S,f.id=a,s.add(f),d={primitive:f,position:void 0,orientation:void 0,minimumClockAngle:void 0,maximumClockAngle:void 0,innerHalfAngle:void 0,outerHalfAngle:void 0},l[a.id]=d),(!e.Cartesian3.equals(h,d.position)||!e.Quaternion.equals(u,d.orientation))&&(e.Matrix4.fromRotationTranslation(e.Matrix3.fromQuaternion(u,K),h,f.modelMatrix),d.position=e.Cartesian3.clone(h,d.position),d.orientation=e.Quaternion.clone(u,d.orientation)),f.show=!0;var _=e.Property.getValueOrDefault(o._minimumClockAngle,t,0),g=e.Property.getValueOrDefault(o._maximumClockAngle,t,e.Math.TWO_PI),I=e.Property.getValueOrDefault(o._innerHalfAngle,t,0),b=e.Property.getValueOrDefault(o._outerHalfAngle,t,Math.PI);(_!==d.minimumClockAngle||g!==d.maximumClockAngle||I!==d.innerHalfAngle||b!==d.outerHalfAngle)&&(Z(f,_,g,I,b),d.innerHalfAngle=I,d.maximumClockAngle=g,d.outerHalfAngle=b,d.minimumClockAngle=_),f.radius=e.Property.getValueOrDefault(o._radius,t,J),f.lateralSurfaceMaterial=e.MaterialProperty.getValue(t,o._lateralSurfaceMaterial,f.lateralSurfaceMaterial),f.intersectionColor=e.Property.getValueOrClonedDefault(o._intersectionColor,t,$,f.intersectionColor),f.intersectionWidth=e.Property.getValueOrDefault(o._intersectionWidth,t,j)}return!0},w.prototype.isDestroyed=function(){return!1},w.prototype.destroy=function(){for(var t=this._entitiesToVisualize.values,i=this._hash,l=this._primitives,s=t.length-1;s>-1;s--)v(t[s],i,l);return e.destroyObject(this)},w.prototype._onCollectionChanged=function(t,i,l,s){var n,r,a=this._entitiesToVisualize,o=this._hash,h=this._primitives;for(n=i.length-1;n>-1;n--)r=i[n],e.defined(r._conicSensor)&&e.defined(r._position)&&e.defined(r._orientation)&&a.set(r.id,r);for(n=s.length-1;n>-1;n--)r=s[n],e.defined(r._conicSensor)&&e.defined(r._position)&&e.defined(r._orientation)?a.set(r.id,r):(v(r,o,h),a.remove(r.id));for(n=l.length-1;n>-1;n--)r=l[n],v(r,o,h),a.remove(r.id)};const A=function(t){this._directions=void 0,this._directionsSubscription=void 0,this._lateralSurfaceMaterial=void 0,this._lateralSurfaceMaterialSubscription=void 0,this._intersectionColor=void 0,this._intersectionColorSubscription=void 0,this._intersectionWidth=void 0,this._intersectionWidthSubscription=void 0,this._showIntersection=void 0,this._showIntersectionSubscription=void 0,this._radius=void 0,this._radiusSubscription=void 0,this._show=void 0,this._showSubscription=void 0,this._definitionChanged=new e.Event,this.merge(e.defaultValue(t,e.defaultValue.EMPTY_OBJECT))};Object.defineProperties(A.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},directions:e.createPropertyDescriptor("directions"),lateralSurfaceMaterial:e.createMaterialPropertyDescriptor("lateralSurfaceMaterial"),intersectionColor:e.createPropertyDescriptor("intersectionColor"),intersectionWidth:e.createPropertyDescriptor("intersectionWidth"),showIntersection:e.createPropertyDescriptor("showIntersection"),radius:e.createPropertyDescriptor("radius"),show:e.createPropertyDescriptor("show")}),A.prototype.clone=function(t){return e.defined(t)||(t=new A),t.directions=this.directions,t.radius=this.radius,t.show=this.show,t.showIntersection=this.showIntersection,t.intersectionColor=this.intersectionColor,t.intersectionWidth=this.intersectionWidth,t.lateralSurfaceMaterial=this.lateralSurfaceMaterial,t},A.prototype.merge=function(t){if(!e.defined(t))throw new e.DeveloperError("source is required.");this.directions=e.defaultValue(this.directions,t.directions),this.radius=e.defaultValue(this.radius,t.radius),this.show=e.defaultValue(this.show,t.show),this.showIntersection=e.defaultValue(this.showIntersection,t.showIntersection),this.intersectionColor=e.defaultValue(this.intersectionColor,t.intersectionColor),this.intersectionWidth=e.defaultValue(this.intersectionWidth,t.intersectionWidth),this.lateralSurfaceMaterial=e.defaultValue(this.lateralSurfaceMaterial,t.lateralSurfaceMaterial)};const G=e.Color.WHITE,ee=1,te=Number.POSITIVE_INFINITY,ne=new e.Matrix3,re=new e.Cartesian3,ie=new e.Quaternion,y=function(t,i){if(!e.defined(t))throw new e.DeveloperError("scene is required.");if(!e.defined(i))throw new e.DeveloperError("entityCollection is required.");i.collectionChanged.addEventListener(y.prototype._onCollectionChanged,this),this._scene=t,this._primitives=t.primitives,this._entityCollection=i,this._hash={},this._entitiesToVisualize=new e.AssociativeArray,this._onCollectionChanged(i,i.values,[],[])};y.prototype.update=function(t){if(!e.defined(t))throw new e.DeveloperError("time is required.");for(var i=this._entitiesToVisualize.values,l=this._hash,s=this._primitives,n=0,r=i.length;n<r;n++){var a=i[n],o=a._customPatternSensor,h,u,d,c=l[a.id],f=a.isShowing&&a.isAvailable(t)&&e.Property.getValueOrDefault(o._show,t,!0);if(f&&(h=e.Property.getValueOrUndefined(a._position,t,re),u=e.Property.getValueOrUndefined(a._orientation,t,ie),d=e.Property.getValueOrUndefined(o._directions,t),f=e.defined(h)&&e.defined(u)&&e.defined(d)),!f){e.defined(c)&&(c.primitive.show=!1);continue}var _=e.defined(c)?c.primitive:void 0;e.defined(_)||(_=new S,_.id=a,s.add(_),c={primitive:_,position:void 0,orientation:void 0},l[a.id]=c),(!e.Cartesian3.equals(h,c.position)||!e.Quaternion.equals(u,c.orientation))&&(e.Matrix4.fromRotationTranslation(e.Matrix3.fromQuaternion(u,ne),h,_.modelMatrix),c.position=e.Cartesian3.clone(h,c.position),c.orientation=e.Quaternion.clone(u,c.orientation)),_.show=!0,_.directions=d,_.radius=e.Property.getValueOrDefault(o._radius,t,te),_.lateralSurfaceMaterial=e.MaterialProperty.getValue(t,o._lateralSurfaceMaterial,_.lateralSurfaceMaterial),_.intersectionColor=e.Property.getValueOrClonedDefault(o._intersectionColor,t,G,_.intersectionColor),_.intersectionWidth=e.Property.getValueOrDefault(o._intersectionWidth,t,ee)}return!0},y.prototype.isDestroyed=function(){return!1},y.prototype.destroy=function(){for(var t=this._entitiesToVisualize.values,i=this._hash,l=this._primitives,s=t.length-1;s>-1;s--)v(t[s],i,l);return e.destroyObject(this)},y.prototype._onCollectionChanged=function(t,i,l,s){var n,r,a=this._entitiesToVisualize,o=this._hash,h=this._primitives;for(n=i.length-1;n>-1;n--)r=i[n],e.defined(r._customPatternSensor)&&e.defined(r._position)&&e.defined(r._orientation)&&a.set(r.id,r);for(n=s.length-1;n>-1;n--)r=s[n],e.defined(r._customPatternSensor)&&e.defined(r._position)&&e.defined(r._orientation)?a.set(r.id,r):(v(r,o,h),a.remove(r.id));for(n=l.length-1;n>-1;n--)r=l[n],v(r,o,h),a.remove(r.id)};const V=function(){this._xHalfAngle=void 0,this._xHalfAngleSubscription=void 0,this._yHalfAngle=void 0,this._yHalfAngleSubscription=void 0,this._lateralSurfaceMaterial=void 0,this._lateralSurfaceMaterialSubscription=void 0,this._intersectionColor=void 0,this._intersectionColorSubscription=void 0,this._intersectionWidth=void 0,this._intersectionWidthSubscription=void 0,this._showIntersection=void 0,this._showIntersectionSubscription=void 0,this._radius=void 0,this._radiusSubscription=void 0,this._show=void 0,this._showSubscription=void 0,this._definitionChanged=new e.Event};Object.defineProperties(V.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},xHalfAngle:e.createPropertyDescriptor("xHalfAngle"),yHalfAngle:e.createPropertyDescriptor("yHalfAngle"),lateralSurfaceMaterial:e.createPropertyDescriptor("lateralSurfaceMaterial"),intersectionColor:e.createPropertyDescriptor("intersectionColor"),intersectionWidth:e.createPropertyDescriptor("intersectionWidth"),showIntersection:e.createPropertyDescriptor("showIntersection"),radius:e.createPropertyDescriptor("radius"),show:e.createPropertyDescriptor("show")}),V.prototype.clone=function(t){return e.defined(t)||(t=new V),t.xHalfAngle=this.xHalfAngle,t.yHalfAngle=this.yHalfAngle,t.radius=this.radius,t.show=this.show,t.showIntersection=this.showIntersection,t.intersectionColor=this.intersectionColor,t.intersectionWidth=this.intersectionWidth,t.lateralSurfaceMaterial=this.lateralSurfaceMaterial,t},V.prototype.merge=function(t){if(!e.defined(t))throw new e.DeveloperError("source is required.");this.xHalfAngle=e.defaultValue(this.xHalfAngle,t.xHalfAngle),this.yHalfAngle=e.defaultValue(this.yHalfAngle,t.yHalfAngle),this.radius=e.defaultValue(this.radius,t.radius),this.show=e.defaultValue(this.show,t.show),this.showIntersection=e.defaultValue(this.showIntersection,t.showIntersection),this.intersectionColor=e.defaultValue(this.intersectionColor,t.intersectionColor),this.intersectionWidth=e.defaultValue(this.intersectionWidth,t.intersectionWidth),this.lateralSurfaceMaterial=e.defaultValue(this.lateralSurfaceMaterial,t.lateralSurfaceMaterial)};function T(t,i,l,s){var n=i[t];e.defined(n)||(n=new e.Spherical,i[t]=n),n.clock=l,n.cone=s,n.magnitude=1}function W(t){var i=t._customSensor.directions,l=Math.tan(Math.min(t._xHalfAngle,e.Math.toRadians(89))),s=Math.tan(Math.min(t._yHalfAngle,e.Math.toRadians(89))),n=Math.atan(l/s),r=Math.atan(Math.sqrt(l*l+s*s));T(0,i,n,r),T(1,i,e.Math.toRadians(180)-n,r),T(2,i,e.Math.toRadians(180)+n,r),T(3,i,-n,r),i.length=4,t._customSensor.directions=i}const x=function(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT);var i=e.clone(t);i._pickPrimitive=e.defaultValue(t._pickPrimitive,this),i.directions=void 0,this._customSensor=new S(i),this._xHalfAngle=e.defaultValue(t.xHalfAngle,e.Math.PI_OVER_TWO),this._yHalfAngle=e.defaultValue(t.yHalfAngle,e.Math.PI_OVER_TWO),W(this)};Object.defineProperties(x.prototype,{xHalfAngle:{get:function(){return this._xHalfAngle},set:function(t){if(t>e.Math.PI_OVER_TWO)throw new e.DeveloperError("xHalfAngle must be less than or equal to 90 degrees.");this._xHalfAngle!==t&&(this._xHalfAngle=t,W(this))}},yHalfAngle:{get:function(){return this._yHalfAngle},set:function(t){if(t>e.Math.PI_OVER_TWO)throw new e.DeveloperError("yHalfAngle must be less than or equal to 90 degrees.");this._yHalfAngle!==t&&(this._yHalfAngle=t,W(this))}},show:{get:function(){return this._customSensor.show},set:function(t){this._customSensor.show=t}},showIntersection:{get:function(){return this._customSensor.showIntersection},set:function(t){this._customSensor.showIntersection=t}},showThroughEllipsoid:{get:function(){return this._customSensor.showThroughEllipsoid},set:function(t){this._customSensor.showThroughEllipsoid=t}},modelMatrix:{get:function(){return this._customSensor.modelMatrix},set:function(t){this._customSensor.modelMatrix=t}},radius:{get:function(){return this._customSensor.radius},set:function(t){this._customSensor.radius=t}},lateralSurfaceMaterial:{get:function(){return this._customSensor.lateralSurfaceMaterial},set:function(t){this._customSensor.lateralSurfaceMaterial=t}},intersectionColor:{get:function(){return this._customSensor.intersectionColor},set:function(t){this._customSensor.intersectionColor=t}},intersectionWidth:{get:function(){return this._customSensor.intersectionWidth},set:function(t){this._customSensor.intersectionWidth=t}},id:{get:function(){return this._customSensor.id},set:function(t){this._customSensor.id=t}}}),x.prototype.update=function(t){this._customSensor.update(t)},x.prototype.isDestroyed=function(){return!1},x.prototype.destroy=function(){return this._customSensor=this._customSensor&&this._customSensor.destroy(),e.destroyObject(this)};const oe=e.Color.WHITE,ae=1,se=Number.POSITIVE_INFINITY,le=new e.Matrix3,de=new e.Cartesian3,he=new e.Quaternion,M=function(t,i){if(!e.defined(t))throw new e.DeveloperError("scene is required.");if(!e.defined(i))throw new e.DeveloperError("entityCollection is required.");i.collectionChanged.addEventListener(M.prototype._onCollectionChanged,this),this._scene=t,this._primitives=t.primitives,this._entityCollection=i,this._hash={},this._entitiesToVisualize=new e.AssociativeArray,this._onCollectionChanged(i,i.values,[],[])};M.prototype.update=function(t){if(!e.defined(t))throw new e.DeveloperError("time is required.");for(var i=this._entitiesToVisualize.values,l=this._hash,s=this._primitives,n=0,r=i.length;n<r;n++){var a=i[n],o=a._rectangularSensor,h,u,d=l[a.id],c=a.isShowing&&a.isAvailable(t)&&e.Property.getValueOrDefault(o._show,t,!0);if(c&&(h=e.Property.getValueOrUndefined(a._position,t,de),u=e.Property.getValueOrUndefined(a._orientation,t,he),c=e.defined(h)&&e.defined(u)),!c){e.defined(d)&&(d.primitive.show=!1);continue}var f=e.defined(d)?d.primitive:void 0;e.defined(f)||(f=new x,f.id=a,s.add(f),d={primitive:f,position:void 0,orientation:void 0},l[a.id]=d),(!e.Cartesian3.equals(h,d.position)||!e.Quaternion.equals(u,d.orientation))&&(e.Matrix4.fromRotationTranslation(e.Matrix3.fromQuaternion(u,le),h,f.modelMatrix),d.position=e.Cartesian3.clone(h,d.position),d.orientation=e.Quaternion.clone(u,d.orientation)),f.show=!0,f.xHalfAngle=e.Property.getValueOrDefault(o._xHalfAngle,t,e.Math.PI_OVER_TWO),f.yHalfAngle=e.Property.getValueOrDefault(o._yHalfAngle,t,e.Math.PI_OVER_TWO),f.radius=e.Property.getValueOrDefault(o._radius,t,se),f.lateralSurfaceMaterial=e.MaterialProperty.getValue(t,o._lateralSurfaceMaterial,f.lateralSurfaceMaterial),f.intersectionColor=e.Property.getValueOrClonedDefault(o._intersectionColor,t,oe,f.intersectionColor),f.intersectionWidth=e.Property.getValueOrDefault(o._intersectionWidth,t,ae)}return!0},M.prototype.isDestroyed=function(){return!1},M.prototype.destroy=function(){for(var t=this._entitiesToVisualize.values,i=this._hash,l=this._primitives,s=t.length-1;s>-1;s--)v(t[s],i,l);return e.destroyObject(this)},M.prototype._onCollectionChanged=function(t,i,l,s){var n,r,a=this._entitiesToVisualize,o=this._hash,h=this._primitives;for(n=i.length-1;n>-1;n--)r=i[n],e.defined(r._rectangularSensor)&&e.defined(r._position)&&e.defined(r._orientation)&&a.set(r.id,r);for(n=s.length-1;n>-1;n--)r=s[n],e.defined(r._rectangularSensor)&&e.defined(r._position)&&e.defined(r._orientation)?a.set(r.id,r):(v(r,o,h),a.remove(r.id));for(n=l.length-1;n>-1;n--)r=l[n],v(r,o,h),a.remove(r.id)};var p=e.CzmlDataSource.processPacketData,fe=e.CzmlDataSource.processMaterialPacketData;function R(t,i,l,s,n){var r,a,o=[],h=i.unitSpherical,u=i.spherical,d=i.unitCartesian,c=i.cartesian;if(e.defined(h)){for(r=0,a=h.length;r<a;r+=2)o.push(new e.Spherical(h[r],h[r+1]));i.array=o}else if(e.defined(u)){for(r=0,a=u.length;r<a;r+=3)o.push(new e.Spherical(u[r],u[r+1],u[r+2]));i.array=o}else if(e.defined(d)){for(r=0,a=d.length;r<a;r+=3){var f=e.Spherical.fromCartesian3(new e.Cartesian3(d[r],d[r+1],d[r+2]));e.Spherical.normalize(f,f),o.push(f)}i.array=o}else if(e.defined(c)){for(r=0,a=c.length;r<a;r+=3)o.push(e.Spherical.fromCartesian3(new e.Cartesian3(c[r],c[r+1],c[r+2])));i.array=o}p(Array,t,"directions",i,l,s,n)}function O(t,i,l,s,n){p(Boolean,t,"show",i.show,l,s,n),p(Number,t,"radius",i.radius,l,s,n),p(Boolean,t,"showIntersection",i.showIntersection,l,s,n),p(e.Color,t,"intersectionColor",i.intersectionColor,l,s,n),p(Number,t,"intersectionWidth",i.intersectionWidth,l,s,n),fe(t,"lateralSurfaceMaterial",i.lateralSurfaceMaterial,l,s,n)}var E={iso8601:void 0};function ue(t,i,l,s){var n=i.agi_conicSensor;if(e.defined(n)){var r,a=n.interval;e.defined(a)&&(E.iso8601=a,r=e.TimeInterval.fromIso8601(E));var o=t.conicSensor;e.defined(o)||(t.addProperty("conicSensor"),o=new C,t.conicSensor=o),O(o,n,r,s,l),p(Number,o,"innerHalfAngle",n.innerHalfAngle,r,s,l),p(Number,o,"outerHalfAngle",n.outerHalfAngle,r,s,l),p(Number,o,"minimumClockAngle",n.minimumClockAngle,r,s,l),p(Number,o,"maximumClockAngle",n.maximumClockAngle,r,s,l)}}function ce(t,i,l,s){var n=i.agi_customPatternSensor;if(e.defined(n)){var r,a=n.interval;e.defined(a)&&(E.iso8601=a,r=e.TimeInterval.fromIso8601(E));var o=t.customPatternSensor;e.defined(o)||(t.addProperty("customPatternSensor"),o=new A,t.customPatternSensor=o),O(o,n,r,s,l);var h=n.directions;if(e.defined(h))if(Array.isArray(h))for(var u=h.length,d=0;d<u;d++)R(o,h[d],r,s,l);else R(o,h,r,s,l)}}function _e(t,i,l,s){var n=i.agi_rectangularSensor;if(e.defined(n)){var r,a=n.interval;e.defined(a)&&(E.iso8601=a,r=e.TimeInterval.fromIso8601(E));var o=t.rectangularSensor;e.defined(o)||(t.addProperty("rectangularSensor"),o=new V,t.rectangularSensor=o),O(o,n,r,s,l),p(Number,o,"xHalfAngle",n.xHalfAngle,r,s,l),p(Number,o,"yHalfAngle",n.yHalfAngle,r,s,l)}}var N=!1;function pe(){if(!N){e.CzmlDataSource.updaters.push(ue,ce,_e);var t=e.DataSourceDisplay.defaultVisualizersCallback;e.DataSourceDisplay.defaultVisualizersCallback=function(i,l,s){var n=s.entities,r=t(i,l,s);return r.concat([new w(i,n),new y(i,n),new M(i,n)])},N=!0}}return pe(),{ConicSensorGraphics:C,ConicSensorVisualizer:w,CustomPatternSensorGraphics:A,CustomPatternSensorVisualizer:y,CustomSensorVolume:S,RectangularPyramidSensorVolume:x,RectangularSensorGraphics:V,RectangularSensorVisualizer:M}});
