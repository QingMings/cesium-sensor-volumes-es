"use strict";const e=require("cesium"),M=function(t){this._minimumClockAngle=void 0,this._minimumClockAngleSubscription=void 0,this._maximumClockAngle=void 0,this._maximumClockAngleSubscription=void 0,this._innerHalfAngle=void 0,this._innerHalfAngleSubscription=void 0,this._outerHalfAngle=void 0,this._outerHalfAngleSubscription=void 0,this._lateralSurfaceMaterial=void 0,this._lateralSurfaceMaterialSubscription=void 0,this._intersectionColor=void 0,this._intersectionColorSubscription=void 0,this._intersectionWidth=void 0,this._intersectionWidthSubscription=void 0,this._showIntersection=void 0,this._showIntersectionSubscription=void 0,this._radius=void 0,this._radiusSubscription=void 0,this._show=void 0,this._showSubscription=void 0,this._definitionChanged=new e.Event,this.merge(e.defaultValue(t,e.defaultValue.EMPTY_OBJECT))};Object.defineProperties(M.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},minimumClockAngle:e.createPropertyDescriptor("minimumClockAngle"),maximumClockAngle:e.createPropertyDescriptor("maximumClockAngle"),innerHalfAngle:e.createPropertyDescriptor("innerHalfAngle"),outerHalfAngle:e.createPropertyDescriptor("outerHalfAngle"),lateralSurfaceMaterial:e.createMaterialPropertyDescriptor("lateralSurfaceMaterial"),intersectionColor:e.createPropertyDescriptor("intersectionColor"),intersectionWidth:e.createPropertyDescriptor("intersectionWidth"),showIntersection:e.createPropertyDescriptor("showIntersection"),radius:e.createPropertyDescriptor("radius"),show:e.createPropertyDescriptor("show")});M.prototype.clone=function(t){return e.defined(t)||(t=new M),t.show=this.show,t.innerHalfAngle=this.innerHalfAngle,t.outerHalfAngle=this.outerHalfAngle,t.minimumClockAngle=this.minimumClockAngle,t.maximumClockAngle=this.maximumClockAngle,t.radius=this.radius,t.showIntersection=this.showIntersection,t.intersectionColor=this.intersectionColor,t.intersectionWidth=this.intersectionWidth,t.lateralSurfaceMaterial=this.lateralSurfaceMaterial,t};M.prototype.merge=function(t){if(!e.defined(t))throw new e.DeveloperError("source is required.");this.show=e.defaultValue(this.show,t.show),this.innerHalfAngle=e.defaultValue(this.innerHalfAngle,t.innerHalfAngle),this.outerHalfAngle=e.defaultValue(this.outerHalfAngle,t.outerHalfAngle),this.minimumClockAngle=e.defaultValue(this.minimumClockAngle,t.minimumClockAngle),this.maximumClockAngle=e.defaultValue(this.maximumClockAngle,t.maximumClockAngle),this.radius=e.defaultValue(this.radius,t.radius),this.showIntersection=e.defaultValue(this.showIntersection,t.showIntersection),this.intersectionColor=e.defaultValue(this.intersectionColor,t.intersectionColor),this.intersectionWidth=e.defaultValue(this.intersectionWidth,t.intersectionWidth),this.lateralSurfaceMaterial=e.defaultValue(this.lateralSurfaceMaterial,t.lateralSurfaceMaterial)};const O=`#version 300 es

uniform vec4 u_intersectionColor;
uniform float u_intersectionWidth;

bool inSensorShadow(vec3 coneVertexWC, vec3 pointWC)
{
    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.
    vec3 D = czm_ellipsoidInverseRadii;

    // Sensor vertex in the scaled ellipsoid space
    vec3 q = D * coneVertexWC;
    float qMagnitudeSquared = dot(q, q);
    float test = qMagnitudeSquared - 1.0;

    // Sensor vertex to fragment vector in the ellipsoid's scaled space
    vec3 temp = D * pointWC - q;
    float d = dot(temp, q);

    // Behind silhouette plane and inside silhouette cone
    return (d < -test) && (d / length(temp) < -sqrt(test));
}

vec4 getIntersectionColor()
{
    return u_intersectionColor;
}

float getIntersectionWidth()
{
    return u_intersectionWidth;
}

vec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)
{
    // (s, t) both in the range [0, 1]
    float t = pointMC.z / sensorRadius;
    float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);
    s = s - floor(s);

    return vec2(s, t);
}
`,H=`#version 300 es

uniform bool u_showIntersection;
uniform bool u_showThroughEllipsoid;

uniform float u_sensorRadius;
uniform float u_normalDirection;

in vec3 v_positionWC;
in vec3 v_positionEC;
in vec3 v_normalEC;

vec4 getColor(float sensorRadius, vec3 pointEC)
{
    czm_materialInput materialInput;

    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;
    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);
    materialInput.str = pointMC / sensorRadius;

    vec3 positionToEyeEC = -v_positionEC;
    materialInput.positionToEyeEC = positionToEyeEC;

    vec3 normalEC = normalize(v_normalEC);
    materialInput.normalEC = u_normalDirection * normalEC;

    czm_material material = czm_getMaterial(materialInput);
    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);
}

bool isOnBoundary(float value, float epsilon)
{
    float width = getIntersectionWidth();
    float tolerance = width * epsilon;

    float delta = max(abs(dFdx(value)), abs(dFdy(value)));
    float pixels = width * delta;
    float temp = abs(value);
    // There are a couple things going on here.
    // First we test the value at the current fragment to see if it is within the tolerance.
    // We also want to check if the value of an adjacent pixel is within the tolerance,
    // but we don't want to admit points that are obviously not on the surface.
    // For example, if we are looking for "value" to be close to 0, but value is 1 and the adjacent value is 2,
    // then the delta would be 1 and "temp - delta" would be "1 - 1" which is zero even though neither of
    // the points is close to zero.
    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);
}

vec4 shade(bool isOnBoundary)
{
    if (u_showIntersection && isOnBoundary)
    {
        return getIntersectionColor();
    }
    return getColor(u_sensorRadius, v_positionEC);
}

float ellipsoidSurfaceFunction(vec3 point)
{
    vec3 scaled = czm_ellipsoidInverseRadii * point;
    return dot(scaled, scaled) - 1.0;
}

void main()
{
    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates
    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates

    float ellipsoidValue = ellipsoidSurfaceFunction(v_positionWC);

    // Occluded by the ellipsoid?
    if (!u_showThroughEllipsoid)
    {
        // Discard if in the ellipsoid
        // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.
        if (ellipsoidValue < 0.0)
        {
            discard;
        }

        // Discard if in the sensor's shadow
        if (inSensorShadow(sensorVertexWC, v_positionWC))
        {
            discard;
        }
    }

    // Discard if not in the sensor's sphere
    // PERFORMANCE_IDEA: We can omit this check if the radius is Number.POSITIVE_INFINITY.
    if (distance(v_positionEC, sensorVertexEC) > u_sensorRadius)
    {
        discard;
    }

    // Notes: Each surface functions should have an associated tolerance based on the floating point error.
    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);
    out_FragColor = shade(isOnEllipsoid);
}
`,k=`#version 300 es

in vec4 position;
in vec3 normal;

out vec3 v_positionWC;
out vec3 v_positionEC;
out vec3 v_normalEC;

void main()
{
    gl_Position = czm_modelViewProjection * position;
    v_positionWC = (czm_model * position).xyz;
    v_positionEC = (czm_modelView * position).xyz;
    v_normalEC = czm_normal * normal;
}
`,D={position:0,normal:1},N=5906376272e3,g=function(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT),this._pickId=void 0,this._pickPrimitive=e.defaultValue(t._pickPrimitive,this),this._frontFaceColorCommand=new e.DrawCommand,this._backFaceColorCommand=new e.DrawCommand,this._pickCommand=new e.DrawCommand,this._boundingSphere=new e.BoundingSphere,this._boundingSphereWC=new e.BoundingSphere,this._frontFaceColorCommand.primitiveType=e.PrimitiveType.TRIANGLES,this._frontFaceColorCommand.boundingVolume=this._boundingSphereWC,this._frontFaceColorCommand.owner=this,this._backFaceColorCommand.primitiveType=this._frontFaceColorCommand.primitiveType,this._backFaceColorCommand.boundingVolume=this._frontFaceColorCommand.boundingVolume,this._backFaceColorCommand.owner=this,this._pickCommand.primitiveType=this._frontFaceColorCommand.primitiveType,this._pickCommand.boundingVolume=this._frontFaceColorCommand.boundingVolume,this._pickCommand.owner=this,this.show=e.defaultValue(t.show,!0),this.showIntersection=e.defaultValue(t.showIntersection,!0),this.showThroughEllipsoid=e.defaultValue(t.showThroughEllipsoid,!1),this._showThroughEllipsoid=this.showThroughEllipsoid,this.modelMatrix=e.Matrix4.clone(e.defaultValue(t.modelMatrix,e.Matrix4.IDENTITY)),this._modelMatrix=new e.Matrix4,this.radius=e.defaultValue(t.radius,Number.POSITIVE_INFINITY),this._directions=void 0,this._directionsDirty=!1,this.directions=e.defined(t.directions)?t.directions:[],this.lateralSurfaceMaterial=e.defined(t.lateralSurfaceMaterial)?t.lateralSurfaceMaterial:e.Material.fromType(e.Material.ColorType),this._lateralSurfaceMaterial=void 0,this._translucent=void 0,this.intersectionColor=e.Color.clone(e.defaultValue(t.intersectionColor,e.Color.WHITE)),this.intersectionWidth=e.defaultValue(t.intersectionWidth,5),this.id=t.id,this._id=void 0;var r=this;this._uniforms={u_showThroughEllipsoid:function(){return r.showThroughEllipsoid},u_showIntersection:function(){return r.showIntersection},u_sensorRadius:function(){return isFinite(r.radius)?r.radius:N},u_intersectionColor:function(){return r.intersectionColor},u_intersectionWidth:function(){return r.intersectionWidth},u_normalDirection:function(){return 1}},this._mode=e.SceneMode.SCENE3D};Object.defineProperties(g.prototype,{directions:{get:function(){return this._directions},set:function(t){this._directions=t,this._directionsDirty=!0}}});const B=new e.Cartesian3,q=new e.Cartesian3,L=new e.Cartesian3;function Q(t){for(var r=t._directions,l=r.length,s=new Float32Array(3*l),i=isFinite(t.radius)?t.radius:N,n=[e.Cartesian3.ZERO],a=l-2,o=l-1,h=0;h<l;a=o++,o=h++){var c=e.Cartesian3.fromSpherical(r[a],B),d=e.Cartesian3.fromSpherical(r[o],q),f=e.Cartesian3.fromSpherical(r[h],L),u=Math.max(e.Cartesian3.angleBetween(c,d),e.Cartesian3.angleBetween(d,f)),_=i/Math.cos(u*.5),m=e.Cartesian3.multiplyByScalar(d,_,new e.Cartesian3);s[o*3]=m.x,s[o*3+1]=m.y,s[o*3+2]=m.z,n.push(m)}return e.BoundingSphere.fromPoints(n,t._boundingSphere),s}const F=new e.Cartesian3;function Y(t,r){for(var l=Q(t),s=t._directions.length,i=new Float32Array(2*3*3*s),n=0,a=s-1,o=0;o<s;a=o++){var h=new e.Cartesian3(l[a*3],l[a*3+1],l[a*3+2]),c=new e.Cartesian3(l[o*3],l[o*3+1],l[o*3+2]),d=e.Cartesian3.normalize(e.Cartesian3.cross(c,h,F),F);i[n++]=0,i[n++]=0,i[n++]=0,i[n++]=d.x,i[n++]=d.y,i[n++]=d.z,i[n++]=c.x,i[n++]=c.y,i[n++]=c.z,i[n++]=d.x,i[n++]=d.y,i[n++]=d.z,i[n++]=h.x,i[n++]=h.y,i[n++]=h.z,i[n++]=d.x,i[n++]=d.y,i[n++]=d.z}var f=e.Buffer.createVertexBuffer({context:r,typedArray:new Float32Array(i),usage:e.BufferUsage.STATIC_DRAW}),u=2*3*Float32Array.BYTES_PER_ELEMENT,_=[{index:D.position,vertexBuffer:f,componentsPerAttribute:3,componentDatatype:e.ComponentDatatype.FLOAT,offsetInBytes:0,strideInBytes:u},{index:D.normal,vertexBuffer:f,componentsPerAttribute:3,componentDatatype:e.ComponentDatatype.FLOAT,offsetInBytes:3*Float32Array.BYTES_PER_ELEMENT,strideInBytes:u}];return new e.VertexArray({context:r,attributes:_})}g.prototype.update=function(t){if(this._mode=t.mode,!(!this.show||this._mode!==e.SceneMode.SCENE3D)){var r=t.context,l=t.commandList;if(this.radius<0)throw new e.DeveloperError("this.radius must be greater than or equal to zero.");if(!e.defined(this.lateralSurfaceMaterial))throw new e.DeveloperError("this.lateralSurfaceMaterial must be defined.");var s=this.lateralSurfaceMaterial.isTranslucent();if(this._showThroughEllipsoid!==this.showThroughEllipsoid||!e.defined(this._frontFaceColorCommand.renderState)||this._translucent!==s){this._showThroughEllipsoid=this.showThroughEllipsoid,this._translucent=s;var i;s?(i=e.RenderState.fromCache({depthTest:{enabled:!this.showThroughEllipsoid},depthMask:!1,blending:e.BlendingState.ALPHA_BLEND,cull:{enabled:!0,face:e.CullFace.BACK}}),this._frontFaceColorCommand.renderState=i,this._frontFaceColorCommand.pass=e.Pass.TRANSLUCENT,i=e.RenderState.fromCache({depthTest:{enabled:!this.showThroughEllipsoid},depthMask:!1,blending:e.BlendingState.ALPHA_BLEND,cull:{enabled:!0,face:e.CullFace.FRONT}}),this._backFaceColorCommand.renderState=i,this._backFaceColorCommand.pass=e.Pass.TRANSLUCENT,i=e.RenderState.fromCache({depthTest:{enabled:!this.showThroughEllipsoid},depthMask:!1,blending:e.BlendingState.ALPHA_BLEND}),this._pickCommand.renderState=i):(i=e.RenderState.fromCache({depthTest:{enabled:!0},depthMask:!0}),this._frontFaceColorCommand.renderState=i,this._frontFaceColorCommand.pass=e.Pass.OPAQUE,i=e.RenderState.fromCache({depthTest:{enabled:!0},depthMask:!0}),this._pickCommand.renderState=i)}var n=this._directionsDirty;if(n){this._directionsDirty=!1,this._va=this._va&&this._va.destroy();var a=this._directions;a&&a.length>=3&&(this._frontFaceColorCommand.vertexArray=Y(this,r),this._backFaceColorCommand.vertexArray=this._frontFaceColorCommand.vertexArray,this._pickCommand.vertexArray=this._frontFaceColorCommand.vertexArray)}if(e.defined(this._frontFaceColorCommand.vertexArray)){var o=t.passes,h=!e.Matrix4.equals(this.modelMatrix,this._modelMatrix);h&&e.Matrix4.clone(this.modelMatrix,this._modelMatrix),(n||h)&&e.BoundingSphere.transform(this._boundingSphere,this.modelMatrix,this._boundingSphereWC),this._frontFaceColorCommand.modelMatrix=this.modelMatrix,this._backFaceColorCommand.modelMatrix=this._frontFaceColorCommand.modelMatrix,this._pickCommand.modelMatrix=this._frontFaceColorCommand.modelMatrix;var c=this._lateralSurfaceMaterial!==this.lateralSurfaceMaterial;if(this._lateralSurfaceMaterial=this.lateralSurfaceMaterial,this._lateralSurfaceMaterial.update(r),o.render){var d=this._frontFaceColorCommand,f=this._backFaceColorCommand;if(c||!e.defined(d.shaderProgram)){var u=new e.ShaderSource({sources:[O,this._lateralSurfaceMaterial.shaderSource,H]});d.shaderProgram=e.ShaderProgram.replaceCache({context:r,shaderProgram:d.shaderProgram,vertexShaderSource:k,fragmentShaderSource:u,attributeLocations:D}),d.uniformMap=e.combine(this._uniforms,this._lateralSurfaceMaterial._uniforms),f.shaderProgram=d.shaderProgram,f.uniformMap=e.combine(this._uniforms,this._lateralSurfaceMaterial._uniforms),f.uniformMap.u_normalDirection=function(){return-1}}s?l.push(this._backFaceColorCommand,this._frontFaceColorCommand):l.push(this._frontFaceColorCommand)}if(o.pick){var _=this._pickCommand;if((!e.defined(this._pickId)||this._id!==this.id)&&(this._id=this.id,this._pickId=this._pickId&&this._pickId.destroy(),this._pickId=r.createPickId({primitive:this._pickPrimitive,id:this.id})),c||!e.defined(_.shaderProgram)){var m=new e.ShaderSource({sources:[O,this._lateralSurfaceMaterial.shaderSource,H],pickColorQualifier:"uniform"});_.shaderProgram=e.ShaderProgram.replaceCache({context:r,shaderProgram:_.shaderProgram,vertexShaderSource:k,fragmentShaderSource:m,attributeLocations:D});var E=this,I={czm_pickColor:function(){return E._pickId.color}};_.uniformMap=e.combine(e.combine(this._uniforms,this._lateralSurfaceMaterial._uniforms),I)}_.pass=s?e.Pass.TRANSLUCENT:e.Pass.OPAQUE,l.push(_)}}}};g.prototype.isDestroyed=function(){return!1};g.prototype.destroy=function(){return this._frontFaceColorCommand.vertexArray=this._frontFaceColorCommand.vertexArray&&this._frontFaceColorCommand.vertexArray.destroy(),this._frontFaceColorCommand.shaderProgram=this._frontFaceColorCommand.shaderProgram&&this._frontFaceColorCommand.shaderProgram.destroy(),this._pickCommand.shaderProgram=this._pickCommand.shaderProgram&&this._pickCommand.shaderProgram.destroy(),this._pickId=this._pickId&&this._pickId.destroy(),e.destroyObject(this)};function C(t,r,l){var s=r[t.id];if(e.defined(s)){var i=s.primitive;l.remove(i),i.isDestroyed()||i.destroy(),delete r[t.id]}}const $=e.Color.WHITE,j=1,J=Number.POSITIVE_INFINITY,K=new e.Matrix3,U=new e.Cartesian3,X=new e.Quaternion;function y(t,r,l,s){var i=r[t];e.defined(i)||(i=new e.Spherical,r[t]=i),i.clock=l,i.cone=s,i.magnitude=1}function Z(t,r,l,s,i){var n=t.directions,a,o=0,h=e.Math.toRadians(2);if(r===0&&l===e.Math.TWO_PI)for(a=0;a<e.Math.TWO_PI;a+=h)y(o++,n,a,i);else{for(a=r;a<l;a+=h)y(o++,n,a,i);if(y(o++,n,l,i),s){for(a=l;a>r;a-=h)y(o++,n,a,s);y(o++,n,r,s)}else y(o++,n,l,0)}n.length=o,t.directions=n}const v=function(t,r){if(!e.defined(t))throw new e.DeveloperError("scene is required.");if(!e.defined(r))throw new e.DeveloperError("entityCollection is required.");r.collectionChanged.addEventListener(v.prototype._onCollectionChanged,this),this._scene=t,this._primitives=t.primitives,this._entityCollection=r,this._hash={},this._entitiesToVisualize=new e.AssociativeArray,this._onCollectionChanged(r,r.values,[],[])};v.prototype.update=function(t){if(!e.defined(t))throw new e.DeveloperError("time is required.");for(var r=this._entitiesToVisualize.values,l=this._hash,s=this._primitives,i=0,n=r.length;i<n;i++){var a=r[i],o=a._conicSensor,h,c,d=l[a.id],f=a.isShowing&&a.isAvailable(t)&&e.Property.getValueOrDefault(o._show,t,!0);if(f&&(h=e.Property.getValueOrUndefined(a._position,t,U),c=e.Property.getValueOrUndefined(a._orientation,t,X),f=e.defined(h)&&e.defined(c)),!f){e.defined(d)&&(d.primitive.show=!1);continue}var u=e.defined(d)?d.primitive:void 0;e.defined(u)||(u=new g,u.id=a,s.add(u),d={primitive:u,position:void 0,orientation:void 0,minimumClockAngle:void 0,maximumClockAngle:void 0,innerHalfAngle:void 0,outerHalfAngle:void 0},l[a.id]=d),(!e.Cartesian3.equals(h,d.position)||!e.Quaternion.equals(c,d.orientation))&&(e.Matrix4.fromRotationTranslation(e.Matrix3.fromQuaternion(c,K),h,u.modelMatrix),d.position=e.Cartesian3.clone(h,d.position),d.orientation=e.Quaternion.clone(c,d.orientation)),u.show=!0;var _=e.Property.getValueOrDefault(o._minimumClockAngle,t,0),m=e.Property.getValueOrDefault(o._maximumClockAngle,t,e.Math.TWO_PI),E=e.Property.getValueOrDefault(o._innerHalfAngle,t,0),I=e.Property.getValueOrDefault(o._outerHalfAngle,t,Math.PI);(_!==d.minimumClockAngle||m!==d.maximumClockAngle||E!==d.innerHalfAngle||I!==d.outerHalfAngle)&&(Z(u,_,m,E,I),d.innerHalfAngle=E,d.maximumClockAngle=m,d.outerHalfAngle=I,d.minimumClockAngle=_),u.radius=e.Property.getValueOrDefault(o._radius,t,J),u.lateralSurfaceMaterial=e.MaterialProperty.getValue(t,o._lateralSurfaceMaterial,u.lateralSurfaceMaterial),u.intersectionColor=e.Property.getValueOrClonedDefault(o._intersectionColor,t,$,u.intersectionColor),u.intersectionWidth=e.Property.getValueOrDefault(o._intersectionWidth,t,j)}return!0};v.prototype.isDestroyed=function(){return!1};v.prototype.destroy=function(){for(var t=this._entitiesToVisualize.values,r=this._hash,l=this._primitives,s=t.length-1;s>-1;s--)C(t[s],r,l);return e.destroyObject(this)};v.prototype._onCollectionChanged=function(t,r,l,s){var i,n,a=this._entitiesToVisualize,o=this._hash,h=this._primitives;for(i=r.length-1;i>-1;i--)n=r[i],e.defined(n._conicSensor)&&e.defined(n._position)&&e.defined(n._orientation)&&a.set(n.id,n);for(i=s.length-1;i>-1;i--)n=s[i],e.defined(n._conicSensor)&&e.defined(n._position)&&e.defined(n._orientation)?a.set(n.id,n):(C(n,o,h),a.remove(n.id));for(i=l.length-1;i>-1;i--)n=l[i],C(n,o,h),a.remove(n.id)};const P=function(t){this._directions=void 0,this._directionsSubscription=void 0,this._lateralSurfaceMaterial=void 0,this._lateralSurfaceMaterialSubscription=void 0,this._intersectionColor=void 0,this._intersectionColorSubscription=void 0,this._intersectionWidth=void 0,this._intersectionWidthSubscription=void 0,this._showIntersection=void 0,this._showIntersectionSubscription=void 0,this._radius=void 0,this._radiusSubscription=void 0,this._show=void 0,this._showSubscription=void 0,this._definitionChanged=new e.Event,this.merge(e.defaultValue(t,e.defaultValue.EMPTY_OBJECT))};Object.defineProperties(P.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},directions:e.createPropertyDescriptor("directions"),lateralSurfaceMaterial:e.createMaterialPropertyDescriptor("lateralSurfaceMaterial"),intersectionColor:e.createPropertyDescriptor("intersectionColor"),intersectionWidth:e.createPropertyDescriptor("intersectionWidth"),showIntersection:e.createPropertyDescriptor("showIntersection"),radius:e.createPropertyDescriptor("radius"),show:e.createPropertyDescriptor("show")});P.prototype.clone=function(t){return e.defined(t)||(t=new P),t.directions=this.directions,t.radius=this.radius,t.show=this.show,t.showIntersection=this.showIntersection,t.intersectionColor=this.intersectionColor,t.intersectionWidth=this.intersectionWidth,t.lateralSurfaceMaterial=this.lateralSurfaceMaterial,t};P.prototype.merge=function(t){if(!e.defined(t))throw new e.DeveloperError("source is required.");this.directions=e.defaultValue(this.directions,t.directions),this.radius=e.defaultValue(this.radius,t.radius),this.show=e.defaultValue(this.show,t.show),this.showIntersection=e.defaultValue(this.showIntersection,t.showIntersection),this.intersectionColor=e.defaultValue(this.intersectionColor,t.intersectionColor),this.intersectionWidth=e.defaultValue(this.intersectionWidth,t.intersectionWidth),this.lateralSurfaceMaterial=e.defaultValue(this.lateralSurfaceMaterial,t.lateralSurfaceMaterial)};const G=e.Color.WHITE,ee=1,te=Number.POSITIVE_INFINITY,ie=new e.Matrix3,ne=new e.Cartesian3,re=new e.Quaternion,S=function(t,r){if(!e.defined(t))throw new e.DeveloperError("scene is required.");if(!e.defined(r))throw new e.DeveloperError("entityCollection is required.");r.collectionChanged.addEventListener(S.prototype._onCollectionChanged,this),this._scene=t,this._primitives=t.primitives,this._entityCollection=r,this._hash={},this._entitiesToVisualize=new e.AssociativeArray,this._onCollectionChanged(r,r.values,[],[])};S.prototype.update=function(t){if(!e.defined(t))throw new e.DeveloperError("time is required.");for(var r=this._entitiesToVisualize.values,l=this._hash,s=this._primitives,i=0,n=r.length;i<n;i++){var a=r[i],o=a._customPatternSensor,h,c,d,f=l[a.id],u=a.isShowing&&a.isAvailable(t)&&e.Property.getValueOrDefault(o._show,t,!0);if(u&&(h=e.Property.getValueOrUndefined(a._position,t,ne),c=e.Property.getValueOrUndefined(a._orientation,t,re),d=e.Property.getValueOrUndefined(o._directions,t),u=e.defined(h)&&e.defined(c)&&e.defined(d)),!u){e.defined(f)&&(f.primitive.show=!1);continue}var _=e.defined(f)?f.primitive:void 0;e.defined(_)||(_=new g,_.id=a,s.add(_),f={primitive:_,position:void 0,orientation:void 0},l[a.id]=f),(!e.Cartesian3.equals(h,f.position)||!e.Quaternion.equals(c,f.orientation))&&(e.Matrix4.fromRotationTranslation(e.Matrix3.fromQuaternion(c,ie),h,_.modelMatrix),f.position=e.Cartesian3.clone(h,f.position),f.orientation=e.Quaternion.clone(c,f.orientation)),_.show=!0,_.directions=d,_.radius=e.Property.getValueOrDefault(o._radius,t,te),_.lateralSurfaceMaterial=e.MaterialProperty.getValue(t,o._lateralSurfaceMaterial,_.lateralSurfaceMaterial),_.intersectionColor=e.Property.getValueOrClonedDefault(o._intersectionColor,t,G,_.intersectionColor),_.intersectionWidth=e.Property.getValueOrDefault(o._intersectionWidth,t,ee)}return!0};S.prototype.isDestroyed=function(){return!1};S.prototype.destroy=function(){for(var t=this._entitiesToVisualize.values,r=this._hash,l=this._primitives,s=t.length-1;s>-1;s--)C(t[s],r,l);return e.destroyObject(this)};S.prototype._onCollectionChanged=function(t,r,l,s){var i,n,a=this._entitiesToVisualize,o=this._hash,h=this._primitives;for(i=r.length-1;i>-1;i--)n=r[i],e.defined(n._customPatternSensor)&&e.defined(n._position)&&e.defined(n._orientation)&&a.set(n.id,n);for(i=s.length-1;i>-1;i--)n=s[i],e.defined(n._customPatternSensor)&&e.defined(n._position)&&e.defined(n._orientation)?a.set(n.id,n):(C(n,o,h),a.remove(n.id));for(i=l.length-1;i>-1;i--)n=l[i],C(n,o,h),a.remove(n.id)};const A=function(){this._xHalfAngle=void 0,this._xHalfAngleSubscription=void 0,this._yHalfAngle=void 0,this._yHalfAngleSubscription=void 0,this._lateralSurfaceMaterial=void 0,this._lateralSurfaceMaterialSubscription=void 0,this._intersectionColor=void 0,this._intersectionColorSubscription=void 0,this._intersectionWidth=void 0,this._intersectionWidthSubscription=void 0,this._showIntersection=void 0,this._showIntersectionSubscription=void 0,this._radius=void 0,this._radiusSubscription=void 0,this._show=void 0,this._showSubscription=void 0,this._definitionChanged=new e.Event};Object.defineProperties(A.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},xHalfAngle:e.createPropertyDescriptor("xHalfAngle"),yHalfAngle:e.createPropertyDescriptor("yHalfAngle"),lateralSurfaceMaterial:e.createPropertyDescriptor("lateralSurfaceMaterial"),intersectionColor:e.createPropertyDescriptor("intersectionColor"),intersectionWidth:e.createPropertyDescriptor("intersectionWidth"),showIntersection:e.createPropertyDescriptor("showIntersection"),radius:e.createPropertyDescriptor("radius"),show:e.createPropertyDescriptor("show")});A.prototype.clone=function(t){return e.defined(t)||(t=new A),t.xHalfAngle=this.xHalfAngle,t.yHalfAngle=this.yHalfAngle,t.radius=this.radius,t.show=this.show,t.showIntersection=this.showIntersection,t.intersectionColor=this.intersectionColor,t.intersectionWidth=this.intersectionWidth,t.lateralSurfaceMaterial=this.lateralSurfaceMaterial,t};A.prototype.merge=function(t){if(!e.defined(t))throw new e.DeveloperError("source is required.");this.xHalfAngle=e.defaultValue(this.xHalfAngle,t.xHalfAngle),this.yHalfAngle=e.defaultValue(this.yHalfAngle,t.yHalfAngle),this.radius=e.defaultValue(this.radius,t.radius),this.show=e.defaultValue(this.show,t.show),this.showIntersection=e.defaultValue(this.showIntersection,t.showIntersection),this.intersectionColor=e.defaultValue(this.intersectionColor,t.intersectionColor),this.intersectionWidth=e.defaultValue(this.intersectionWidth,t.intersectionWidth),this.lateralSurfaceMaterial=e.defaultValue(this.lateralSurfaceMaterial,t.lateralSurfaceMaterial)};function b(t,r,l,s){var i=r[t];e.defined(i)||(i=new e.Spherical,r[t]=i),i.clock=l,i.cone=s,i.magnitude=1}function T(t){var r=t._customSensor.directions,l=Math.tan(Math.min(t._xHalfAngle,e.Math.toRadians(89))),s=Math.tan(Math.min(t._yHalfAngle,e.Math.toRadians(89))),i=Math.atan(l/s),n=Math.atan(Math.sqrt(l*l+s*s));b(0,r,i,n),b(1,r,e.Math.toRadians(180)-i,n),b(2,r,e.Math.toRadians(180)+i,n),b(3,r,-i,n),r.length=4,t._customSensor.directions=r}const x=function(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT);var r=e.clone(t);r._pickPrimitive=e.defaultValue(t._pickPrimitive,this),r.directions=void 0,this._customSensor=new g(r),this._xHalfAngle=e.defaultValue(t.xHalfAngle,e.Math.PI_OVER_TWO),this._yHalfAngle=e.defaultValue(t.yHalfAngle,e.Math.PI_OVER_TWO),T(this)};Object.defineProperties(x.prototype,{xHalfAngle:{get:function(){return this._xHalfAngle},set:function(t){if(t>e.Math.PI_OVER_TWO)throw new e.DeveloperError("xHalfAngle must be less than or equal to 90 degrees.");this._xHalfAngle!==t&&(this._xHalfAngle=t,T(this))}},yHalfAngle:{get:function(){return this._yHalfAngle},set:function(t){if(t>e.Math.PI_OVER_TWO)throw new e.DeveloperError("yHalfAngle must be less than or equal to 90 degrees.");this._yHalfAngle!==t&&(this._yHalfAngle=t,T(this))}},show:{get:function(){return this._customSensor.show},set:function(t){this._customSensor.show=t}},showIntersection:{get:function(){return this._customSensor.showIntersection},set:function(t){this._customSensor.showIntersection=t}},showThroughEllipsoid:{get:function(){return this._customSensor.showThroughEllipsoid},set:function(t){this._customSensor.showThroughEllipsoid=t}},modelMatrix:{get:function(){return this._customSensor.modelMatrix},set:function(t){this._customSensor.modelMatrix=t}},radius:{get:function(){return this._customSensor.radius},set:function(t){this._customSensor.radius=t}},lateralSurfaceMaterial:{get:function(){return this._customSensor.lateralSurfaceMaterial},set:function(t){this._customSensor.lateralSurfaceMaterial=t}},intersectionColor:{get:function(){return this._customSensor.intersectionColor},set:function(t){this._customSensor.intersectionColor=t}},intersectionWidth:{get:function(){return this._customSensor.intersectionWidth},set:function(t){this._customSensor.intersectionWidth=t}},id:{get:function(){return this._customSensor.id},set:function(t){this._customSensor.id=t}}});x.prototype.update=function(t){this._customSensor.update(t)};x.prototype.isDestroyed=function(){return!1};x.prototype.destroy=function(){return this._customSensor=this._customSensor&&this._customSensor.destroy(),e.destroyObject(this)};const oe=e.Color.WHITE,ae=1,se=Number.POSITIVE_INFINITY,le=new e.Matrix3,de=new e.Cartesian3,he=new e.Quaternion,w=function(t,r){if(!e.defined(t))throw new e.DeveloperError("scene is required.");if(!e.defined(r))throw new e.DeveloperError("entityCollection is required.");r.collectionChanged.addEventListener(w.prototype._onCollectionChanged,this),this._scene=t,this._primitives=t.primitives,this._entityCollection=r,this._hash={},this._entitiesToVisualize=new e.AssociativeArray,this._onCollectionChanged(r,r.values,[],[])};w.prototype.update=function(t){if(!e.defined(t))throw new e.DeveloperError("time is required.");for(var r=this._entitiesToVisualize.values,l=this._hash,s=this._primitives,i=0,n=r.length;i<n;i++){var a=r[i],o=a._rectangularSensor,h,c,d=l[a.id],f=a.isShowing&&a.isAvailable(t)&&e.Property.getValueOrDefault(o._show,t,!0);if(f&&(h=e.Property.getValueOrUndefined(a._position,t,de),c=e.Property.getValueOrUndefined(a._orientation,t,he),f=e.defined(h)&&e.defined(c)),!f){e.defined(d)&&(d.primitive.show=!1);continue}var u=e.defined(d)?d.primitive:void 0;e.defined(u)||(u=new x,u.id=a,s.add(u),d={primitive:u,position:void 0,orientation:void 0},l[a.id]=d),(!e.Cartesian3.equals(h,d.position)||!e.Quaternion.equals(c,d.orientation))&&(e.Matrix4.fromRotationTranslation(e.Matrix3.fromQuaternion(c,le),h,u.modelMatrix),d.position=e.Cartesian3.clone(h,d.position),d.orientation=e.Quaternion.clone(c,d.orientation)),u.show=!0,u.xHalfAngle=e.Property.getValueOrDefault(o._xHalfAngle,t,e.Math.PI_OVER_TWO),u.yHalfAngle=e.Property.getValueOrDefault(o._yHalfAngle,t,e.Math.PI_OVER_TWO),u.radius=e.Property.getValueOrDefault(o._radius,t,se),u.lateralSurfaceMaterial=e.MaterialProperty.getValue(t,o._lateralSurfaceMaterial,u.lateralSurfaceMaterial),u.intersectionColor=e.Property.getValueOrClonedDefault(o._intersectionColor,t,oe,u.intersectionColor),u.intersectionWidth=e.Property.getValueOrDefault(o._intersectionWidth,t,ae)}return!0};w.prototype.isDestroyed=function(){return!1};w.prototype.destroy=function(){for(var t=this._entitiesToVisualize.values,r=this._hash,l=this._primitives,s=t.length-1;s>-1;s--)C(t[s],r,l);return e.destroyObject(this)};w.prototype._onCollectionChanged=function(t,r,l,s){var i,n,a=this._entitiesToVisualize,o=this._hash,h=this._primitives;for(i=r.length-1;i>-1;i--)n=r[i],e.defined(n._rectangularSensor)&&e.defined(n._position)&&e.defined(n._orientation)&&a.set(n.id,n);for(i=s.length-1;i>-1;i--)n=s[i],e.defined(n._rectangularSensor)&&e.defined(n._position)&&e.defined(n._orientation)?a.set(n.id,n):(C(n,o,h),a.remove(n.id));for(i=l.length-1;i>-1;i--)n=l[i],C(n,o,h),a.remove(n.id)};var p=e.CzmlDataSource.processPacketData,ue=e.CzmlDataSource.processMaterialPacketData;function z(t,r,l,s,i){var n,a,o=[],h=r.unitSpherical,c=r.spherical,d=r.unitCartesian,f=r.cartesian;if(e.defined(h)){for(n=0,a=h.length;n<a;n+=2)o.push(new e.Spherical(h[n],h[n+1]));r.array=o}else if(e.defined(c)){for(n=0,a=c.length;n<a;n+=3)o.push(new e.Spherical(c[n],c[n+1],c[n+2]));r.array=o}else if(e.defined(d)){for(n=0,a=d.length;n<a;n+=3){var u=e.Spherical.fromCartesian3(new e.Cartesian3(d[n],d[n+1],d[n+2]));e.Spherical.normalize(u,u),o.push(u)}r.array=o}else if(e.defined(f)){for(n=0,a=f.length;n<a;n+=3)o.push(e.Spherical.fromCartesian3(new e.Cartesian3(f[n],f[n+1],f[n+2])));r.array=o}p(Array,t,"directions",r,l,s,i)}function W(t,r,l,s,i){p(Boolean,t,"show",r.show,l,s,i),p(Number,t,"radius",r.radius,l,s,i),p(Boolean,t,"showIntersection",r.showIntersection,l,s,i),p(e.Color,t,"intersectionColor",r.intersectionColor,l,s,i),p(Number,t,"intersectionWidth",r.intersectionWidth,l,s,i),ue(t,"lateralSurfaceMaterial",r.lateralSurfaceMaterial,l,s,i)}var V={iso8601:void 0};function ce(t,r,l,s){var i=r.agi_conicSensor;if(e.defined(i)){var n,a=i.interval;e.defined(a)&&(V.iso8601=a,n=e.TimeInterval.fromIso8601(V));var o=t.conicSensor;e.defined(o)||(t.addProperty("conicSensor"),o=new M,t.conicSensor=o),W(o,i,n,s,l),p(Number,o,"innerHalfAngle",i.innerHalfAngle,n,s,l),p(Number,o,"outerHalfAngle",i.outerHalfAngle,n,s,l),p(Number,o,"minimumClockAngle",i.minimumClockAngle,n,s,l),p(Number,o,"maximumClockAngle",i.maximumClockAngle,n,s,l)}}function fe(t,r,l,s){var i=r.agi_customPatternSensor;if(e.defined(i)){var n,a=i.interval;e.defined(a)&&(V.iso8601=a,n=e.TimeInterval.fromIso8601(V));var o=t.customPatternSensor;e.defined(o)||(t.addProperty("customPatternSensor"),o=new P,t.customPatternSensor=o),W(o,i,n,s,l);var h=i.directions;if(e.defined(h))if(Array.isArray(h))for(var c=h.length,d=0;d<c;d++)z(o,h[d],n,s,l);else z(o,h,n,s,l)}}function _e(t,r,l,s){var i=r.agi_rectangularSensor;if(e.defined(i)){var n,a=i.interval;e.defined(a)&&(V.iso8601=a,n=e.TimeInterval.fromIso8601(V));var o=t.rectangularSensor;e.defined(o)||(t.addProperty("rectangularSensor"),o=new A,t.rectangularSensor=o),W(o,i,n,s,l),p(Number,o,"xHalfAngle",i.xHalfAngle,n,s,l),p(Number,o,"yHalfAngle",i.yHalfAngle,n,s,l)}}var R=!1;function pe(){if(!R){e.CzmlDataSource.updaters.push(ce,fe,_e);var t=e.DataSourceDisplay.defaultVisualizersCallback;e.DataSourceDisplay.defaultVisualizersCallback=function(r,l,s){var i=s.entities,n=t(r,l,s);return n.concat([new v(r,i),new S(r,i),new w(r,i)])},R=!0}}pe();const me={ConicSensorGraphics:M,ConicSensorVisualizer:v,CustomPatternSensorGraphics:P,CustomPatternSensorVisualizer:S,CustomSensorVolume:g,RectangularPyramidSensorVolume:x,RectangularSensorGraphics:A,RectangularSensorVisualizer:w};module.exports=me;
